<?php

declare(strict_types=1);

namespace Skybolt;

/**
 * Skybolt - High-performance asset caching for multi-page applications
 *
 * Reads the render-map.json generated by @skybolt/vite-plugin and outputs
 * optimized HTML tags with intelligent caching via Service Workers.
 *
 * @package Skybolt
 * @version 3.4.0
 */
class Skybolt
{
    public const VERSION = '3.4.0';

    /** @var array<string, mixed> */
    private array $map;

    /** @var CacheDigest Cache Digest for lookup */
    private CacheDigest $cacheDigest;

    /** @var string|null CDN URL prefix */
    private ?string $cdnUrl;

    /** @var array<string, array{entry: string, hash: string}>|null URL to entry mapping */
    private ?array $urlToEntry = null;

    /**
     * Create a new Skybolt instance
     *
     * @param string $renderMapPath Path to render-map.json generated by Vite plugin
     * @param array<string, string>|null $cookies Cookie array (defaults to $_COOKIE)
     * @param string|null $cdnUrl Optional CDN URL prefix (e.g., 'https://cdn.example.com')
     *
     * @throws \RuntimeException If render map cannot be read
     * @throws \JsonException If render map contains invalid JSON
     */
    public function __construct(
        string $renderMapPath,
        ?array $cookies = null,
        ?string $cdnUrl = null
    ) {
        $json = @file_get_contents($renderMapPath);

        if ($json === false) {
            throw new \RuntimeException("Cannot read render map: {$renderMapPath}");
        }

        $this->map = json_decode($json, true, 512, JSON_THROW_ON_ERROR);
        $this->cdnUrl = $cdnUrl ? rtrim($cdnUrl, '/') : null;

        $cookies = $cookies ?? $_COOKIE;

        // Parse Cache Digest from sb_digest cookie
        $this->cacheDigest = CacheDigest::fromBase64($cookies['sb_digest'] ?? '');
    }

    /**
     * Render CSS asset
     *
     * On first visit: inlines CSS with sb-* attributes for caching
     * On repeat visit: outputs <link> tag (Service Worker serves from cache)
     *
     * @param string $entry Source file path (e.g., 'src/css/main.css')
     * @param bool $async Load CSS asynchronously (non-render-blocking)
     * @return string HTML string
     */
    public function css(string $entry, bool $async = false): string
    {
        $asset = $this->map['assets'][$entry] ?? null;

        if ($asset === null) {
            return $this->comment("Skybolt: asset not found: {$entry}");
        }

        $url = $this->resolveUrl($asset['url']);

        // Client has current version - external link (SW serves from cache)
        if ($this->hasCached($entry, $asset['hash'])) {
            if ($async) {
                // Preload + onload swap for non-blocking load
                return '<link rel="preload" href="' . $this->esc($url) . '" as="style" onload="this.rel=\'stylesheet\'">'
                    . '<noscript><link rel="stylesheet" href="' . $this->esc($url) . '"></noscript>';
            }
            return '<link rel="stylesheet" href="' . $this->esc($url) . '">';
        }

        // First visit - inline with cache attributes
        if ($async) {
            // media="print" trick: browser parses but doesn't apply until onload swaps to "all"
            return '<style'
                . ' media="print" onload="this.media=\'all\'"'
                . ' sb-asset="' . $this->esc($entry) . ':' . $this->esc($asset['hash']) . '"'
                . ' sb-url="' . $this->esc($url) . '">'
                . $asset['content']
                . '</style>';
        }

        return '<style'
            . ' sb-asset="' . $this->esc($entry) . ':' . $this->esc($asset['hash']) . '"'
            . ' sb-url="' . $this->esc($url) . '">'
            . $asset['content']
            . '</style>';
    }

    /**
     * Render JavaScript asset
     *
     * On first visit: inlines JS with sb-* attributes for caching
     * On repeat visit: outputs <script> tag (Service Worker serves from cache)
     *
     * @param string $entry Source file path (e.g., 'src/js/app.js')
     * @param bool $module Whether to load as ES module (default: true)
     * @return string HTML string
     */
    public function script(string $entry, bool $module = true): string
    {
        $asset = $this->map['assets'][$entry] ?? null;

        if ($asset === null) {
            return $this->comment("Skybolt: asset not found: {$entry}");
        }

        $url = $this->resolveUrl($asset['url']);
        $typeAttr = $module ? ' type="module"' : '';

        // Client has current version - external script (SW serves from cache)
        if ($this->hasCached($entry, $asset['hash'])) {
            return '<script' . $typeAttr . ' src="' . $this->esc($url) . '"></script>';
        }

        // First visit - inline with cache attributes
        return '<script' . $typeAttr
            . ' sb-asset="' . $this->esc($entry) . ':' . $this->esc($asset['hash']) . '"'
            . ' sb-url="' . $this->esc($url) . '">'
            . $asset['content']
            . '</script>';
    }

    /**
     * Render preload link for critical resources
     *
     * Use this for fonts, images, or other resources that should load early.
     * Preloaded resources are not cached by Skybolt's Service Worker.
     *
     * @param string $entry Source file path or direct URL
     * @param string $as Resource type ('image', 'font', 'style', 'script', 'fetch')
     * @param string|null $type MIME type (e.g., 'font/woff2', 'image/webp')
     * @param string|null $crossorigin Crossorigin attribute ('anonymous', 'use-credentials')
     * @param string|null $fetchpriority Fetch priority ('high', 'low', 'auto')
     * @return string HTML string
     */
    public function preload(
        string $entry,
        string $as,
        ?string $type = null,
        ?string $crossorigin = null,
        ?string $fetchpriority = null
    ): string {
        // Try to resolve from assets, fall back to using entry as URL
        $url = $this->getAssetUrl($entry) ?? $entry;
        $url = $this->resolveUrl($url);

        $attrs = [
            'rel' => 'preload',
            'href' => $url,
            'as' => $as,
        ];

        if ($type !== null) {
            $attrs['type'] = $type;
        }

        if ($crossorigin !== null) {
            $attrs['crossorigin'] = $crossorigin;
        }

        if ($fetchpriority !== null) {
            $attrs['fetchpriority'] = $fetchpriority;
        }

        return $this->buildTag('link', $attrs);
    }

    /**
     * Render the Skybolt client launcher
     *
     * Call this once in <head> before other Skybolt assets.
     * Outputs config meta tag and client script.
     *
     * On first visit (or cache miss), the launcher is inlined with sb-asset
     * and sb-url attributes so the client can cache itself.
     *
     * On repeat visits (cache hit), returns an external script tag. The Service
     * Worker will serve the launcher from cache (~5ms response time).
     *
     * @return string HTML string
     */
    public function launchScript(): string
    {
        $config = json_encode([
            'swPath' => $this->map['serviceWorker']['path'] ?? '/skybolt-sw.js',
        ], JSON_THROW_ON_ERROR | JSON_UNESCAPED_SLASHES);

        $launcher = $this->map['launcher'];
        $url = $this->resolveUrl($launcher['url']);

        $meta = '<meta name="skybolt-config" content="' . $this->esc($config) . '">' . PHP_EOL;

        if ($this->hasCached('skybolt-launcher', $launcher['hash'])) {
            // Repeat visit - external script (SW serves from cache)
            return $meta . '<script type="module" src="' . $this->esc($url) . '"></script>';
        }

        // First visit - inline with sb-asset and sb-url for self-caching
        return $meta . '<script type="module"'
            . ' sb-asset="skybolt-launcher:' . $this->esc($launcher['hash']) . '"'
            . ' sb-url="' . $this->esc($url) . '">'
            . $launcher['content']
            . '</script>';
    }

    /**
     * Get URL for an asset (for manual use cases)
     *
     * @param string $entry Source file path
     * @return string|null Asset URL or null if not found
     */
    public function getAssetUrl(string $entry): ?string
    {
        $url = $this->map['assets'][$entry]['url'] ?? null;
        return $url !== null ? $this->resolveUrl($url) : null;
    }

    /**
     * Get hash for an asset (for manual use cases)
     *
     * @param string $entry Source file path
     * @return string|null Asset hash or null if not found
     */
    public function getAssetHash(string $entry): ?string
    {
        return $this->map['assets'][$entry]['hash'] ?? null;
    }

    /**
     * Check if an asset URL is currently cached by the client
     *
     * This is useful for Chain Lightning integration where we need to check
     * cache status by URL rather than source path.
     *
     * @param string $url The asset URL (e.g., '/assets/main-Abc123.css')
     * @return bool True if the asset is cached
     */
    public function isCachedUrl(string $url): bool
    {
        // Build URL to entry mapping if not already built
        if ($this->urlToEntry === null) {
            $this->urlToEntry = [];
            foreach ($this->map['assets'] as $entry => $asset) {
                $this->urlToEntry[$asset['url']] = [
                    'entry' => $entry,
                    'hash' => $asset['hash'],
                ];
            }
        }

        $info = $this->urlToEntry[$url] ?? null;
        if ($info === null) {
            return false;
        }

        return $this->hasCached($info['entry'], $info['hash']);
    }

    /**
     * Check if client has a specific entry:hash pair cached.
     *
     * Useful for external integrations (like Chain Lightning) that manage
     * their own assets outside of Skybolt's render-map.
     *
     * @param string $entry The entry name (e.g., 'chain-lightning' or 'cl-manifest')
     * @param string $hash The expected hash value
     * @return bool True if the entry:hash pair is in the client's cache
     */
    public function hasCachedEntry(string $entry, string $hash): bool
    {
        return $this->hasCached($entry, $hash);
    }

    /**
     * Resolve URL with optional CDN prefix
     */
    private function resolveUrl(string $url): string
    {
        if ($this->cdnUrl === null) {
            return $url;
        }

        // Don't prefix absolute URLs
        if (str_starts_with($url, 'http://') || str_starts_with($url, 'https://') || str_starts_with($url, '//')) {
            return $url;
        }

        return $this->cdnUrl . $url;
    }

    /**
     * Check if client has a specific asset version cached
     */
    private function hasCached(string $entry, string $hash): bool
    {
        return $this->cacheDigest->lookup("{$entry}:{$hash}");
    }

    /**
     * Build an HTML tag
     *
     * @param string $tag Tag name
     * @param array<string, string> $attrs Attributes
     * @return string HTML string
     */
    private function buildTag(string $tag, array $attrs): string
    {
        $html = '<' . $tag;
        foreach ($attrs as $key => $value) {
            $html .= ' ' . $key . '="' . $this->esc($value) . '"';
        }
        return $html . '>';
    }

    /**
     * HTML-escape a string
     */
    private function esc(string $value): string
    {
        return htmlspecialchars($value, ENT_QUOTES | ENT_HTML5, 'UTF-8');
    }

    /**
     * Generate HTML comment (for errors/debugging)
     */
    private function comment(string $text): string
    {
        return '<!-- ' . $this->esc($text) . ' -->';
    }
}
